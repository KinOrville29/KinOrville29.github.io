[{"content":" Blowfish 主题深度配置与美化指南 # 本文详细记录如何对 Hugo 的 Blowfish 主题进行全面配置和美化，包括视觉定制、功能增强和交互体验优化。\n基础配置优化 # 站点基本信息配置 # 在 hugo.toml 中完善基础信息配置：\nbaseURL = \u0026#39;https://yourusername.github.io/\u0026#39; title = \u0026#39;你的博客名称\u0026#39; theme = \u0026#39;blowfish\u0026#39; [params] description = \u0026#39;博客详细描述信息\u0026#39; author = \u0026#39;你的姓名\u0026#39; keywords = \u0026#39;关键词1, 关键词2, 关键词3\u0026#39; defaultTheme = \u0026#39;auto\u0026#39; # auto/dark/light [languages.zh-CN] title = \u0026#39;你的博客名称\u0026#39; description = \u0026#39;博客详细描述信息\u0026#39; languageName = \u0026#39;中文\u0026#39; languageCode = \u0026#39;zh-CN\u0026#39; 主题色系定制 # Blowfish 主题支持多种预定义色系，也可完全自定义：\n[params] colorScheme = \u0026#39;custom\u0026#39; # 使用自定义色彩 # 自定义色彩配置 [params.appearance] theme = \u0026#39;custom\u0026#39; customColors = true [params.appearance.colors] primary = \u0026#39;#2B90D9\u0026#39; # 主色调 primaryLight = \u0026#39;#6CB6FF\u0026#39; # 主色调浅色 primaryDark = \u0026#39;#1B6FB1\u0026#39; # 主色调深色 background = \u0026#39;#FFFFFF\u0026#39; # 背景色 surface = \u0026#39;#F8F9FA\u0026#39; # 表面色 onBackground = \u0026#39;#333333\u0026#39; # 背景上的文字色 onSurface = \u0026#39;#444444\u0026#39; # 表面上的文字色 视觉美化配置 # 自定义字体配置 # 创建 assets/css/custom.css 文件来覆盖默认字体：\n/* 中文字体优化 */ :root { --font-family: \u0026#34;Noto Sans SC\u0026#34;, \u0026#34;Source Han Sans CN\u0026#34;, \u0026#34;PingFang SC\u0026#34;, \u0026#34;Microsoft YaHei\u0026#34;, sans-serif; --font-family-heading: \u0026#34;Noto Serif SC\u0026#34;, \u0026#34;Source Han Serif CN\u0026#34;, \u0026#34;SimSun\u0026#34;, \u0026#34;SongTi SC\u0026#34;, serif; --font-family-code: \u0026#34;JetBrains Mono\u0026#34;, \u0026#34;Fira Code\u0026#34;, \u0026#34;Cascadia Code\u0026#34;, monospace; } /* 字体引入 */ @import url(\u0026#39;https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700\u0026amp;family=Noto+Serif+SC:wght@400;600;700\u0026amp;display=swap\u0026#39;); /* 代码块字体优化 */ code, pre { font-family: var(--font-family-code); font-size: 0.9em; } /* 标题字体优化 */ h1, h2, h3, h4, h5, h6 { font-family: var(--font-family-heading); font-weight: 600; } 在配置文件中启用自定义 CSS：\n[params] custom_css = [\u0026#39;css/custom.css\u0026#39;] Logo 与头像配置 # 准备并配置品牌标识和个人头像：\n[params] # Logo 配置 logo = \u0026#39;images/logo.png\u0026#39; logo_width = 40 logo_height = 40 # 头像配置 home_avatar = \u0026#39;images/avatar.jpg\u0026#39; home_avatar_width = 120 home_avatar_height = 120 # 主页背景（可选） home_background = \u0026#39;images/background.jpg\u0026#39; [params.appearance] # 头像样式 avatar_style = \u0026#39;circle\u0026#39; # circle/square # 社交链接 [params.social] GitHub = \u0026#39;https://github.com/yourusername\u0026#39; Email = \u0026#39;mailto:your@email.com\u0026#39; Twitter = \u0026#39;https://twitter.com/yourusername\u0026#39; 将对应的图片文件放置在 assets/images/ 目录下。\n文章缩略图配置 # 为文章添加特色图片和封面：\n[params.article] # 文章列表显示特色图片 show_featured_image = true # 文章内显示封面图片 show_cover = true # 图片懒加载 image_lazy_loading = true 在文章 Front Matter 中配置封面：\n--- title: \u0026#34;文章标题\u0026#34; date: 2023-11-15 cover: image: \u0026#34;images/posts/cover1.jpg\u0026#34; alt: \u0026#34;封面图片描述\u0026#34; caption: \u0026#34;图片说明（可选）\u0026#34; hidden: false # 在文章页隐藏封面 featured_image: \u0026#34;images/posts/featured1.jpg\u0026#34; --- 动态背景效果 # 樱花飘落效果 # 创建 assets/js/sakura.js 文件：\nclass SakuraFall { constructor() { this.canvas = null; this.ctx = null; this.sakuras = []; this.init(); } init() { this.createCanvas(); this.createSakuras(30); this.animate(); window.addEventListener(\u0026#39;resize\u0026#39;, () =\u0026gt; { this.resizeCanvas(); }); } createCanvas() { this.canvas = document.createElement(\u0026#39;canvas\u0026#39;); this.ctx = this.canvas.getContext(\u0026#39;2d\u0026#39;); this.canvas.style.position = \u0026#39;fixed\u0026#39;; this.canvas.style.top = \u0026#39;0\u0026#39;; this.canvas.style.left = \u0026#39;0\u0026#39;; this.canvas.style.width = \u0026#39;100%\u0026#39;; this.canvas.style.height = \u0026#39;100%\u0026#39;; this.canvas.style.pointerEvents = \u0026#39;none\u0026#39;; this.canvas.style.zIndex = \u0026#39;9999\u0026#39;; document.body.appendChild(this.canvas); this.resizeCanvas(); } resizeCanvas() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; } createSakuras(count) { for (let i = 0; i \u0026lt; count; i++) { this.sakuras.push({ x: Math.random() * this.canvas.width, y: Math.random() * -this.canvas.height, size: Math.random() * 5 + 2, speed: Math.random() * 2 + 1, swing: Math.random() * 2, swingSpeed: Math.random() * 0.02 + 0.01, angle: 0 }); } } animate() { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = \u0026#39;rgba(255, 183, 197, 0.7)\u0026#39;; this.sakuras.forEach(sakura =\u0026gt; { // 更新位置 sakura.y += sakura.speed; sakura.angle += sakura.swingSpeed; sakura.x += Math.sin(sakura.angle) * sakura.swing; // 绘制花瓣（简单的五瓣花） this.ctx.save(); this.ctx.translate(sakura.x, sakura.y); this.ctx.rotate(sakura.angle); this.ctx.beginPath(); for (let i = 0; i \u0026lt; 5; i++) { const angle = (i * 2 * Math.PI) / 5; const x = Math.cos(angle) * sakura.size; const y = Math.sin(angle) * sakura.size; if (i === 0) { this.ctx.moveTo(x, y); } else { this.ctx.lineTo(x, y); } } this.ctx.closePath(); this.ctx.fill(); this.ctx.restore(); // 重置位置 if (sakura.y \u0026gt; this.canvas.height) { sakura.y = -10; sakura.x = Math.random() * this.canvas.width; } }); requestAnimationFrame(() =\u0026gt; this.animate()); } } // 在页面加载后初始化 if (document.readyState === \u0026#39;loading\u0026#39;) { document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, () =\u0026gt; { new SakuraFall(); }); } else { new SakuraFall(); } 蛛网背景效果 # 创建 assets/js/spiderweb.js：\nclass SpiderWeb { constructor() { this.canvas = null; this.ctx = null; this.points = []; this.mouse = { x: 0, y: 0 }; this.init(); } init() { this.createCanvas(); this.createPoints(); this.animate(); document.addEventListener(\u0026#39;mousemove\u0026#39;, (e) =\u0026gt; { this.mouse.x = e.clientX; this.mouse.y = e.clientY; }); window.addEventListener(\u0026#39;resize\u0026#39;, () =\u0026gt; { this.resizeCanvas(); this.createPoints(); }); } createCanvas() { this.canvas = document.createElement(\u0026#39;canvas\u0026#39;); this.ctx = this.canvas.getContext(\u0026#39;2d\u0026#39;); this.canvas.style.position = \u0026#39;fixed\u0026#39;; this.canvas.style.top = \u0026#39;0\u0026#39;; this.canvas.style.left = \u0026#39;0\u0026#39;; this.canvas.style.width = \u0026#39;100%\u0026#39;; this.canvas.style.height = \u0026#39;100%\u0026#39;; this.canvas.style.pointerEvents = \u0026#39;none\u0026#39;; this.canvas.style.zIndex = \u0026#39;1\u0026#39;; this.canvas.style.opacity = \u0026#39;0.1\u0026#39;; document.body.appendChild(this.canvas); this.resizeCanvas(); } resizeCanvas() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; } createPoints() { this.points = []; const count = Math.min(15, Math.floor((this.canvas.width * this.canvas.height) / 50000)); for (let i = 0; i \u0026lt; count; i++) { this.points.push({ x: Math.random() * this.canvas.width, y: Math.random() * this.canvas.height, vx: (Math.random() - 0.5) * 0.5, vy: (Math.random() - 0.5) * 0.5, connections: [] }); } } drawWeb() { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.strokeStyle = \u0026#39;rgba(200, 200, 200, 0.3)\u0026#39;; this.ctx.lineWidth = 0.5; // 绘制连线 this.points.forEach((point, i) =\u0026gt; { point.connections = []; this.points.forEach((other, j) =\u0026gt; { if (i !== j) { const dx = point.x - other.x; const dy = point.y - other.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance \u0026lt; 150) { point.connections.push(other); this.ctx.beginPath(); this.ctx.moveTo(point.x, point.y); this.ctx.lineTo(other.x, other.y); this.ctx.stroke(); } } }); }); // 绘制点 this.ctx.fillStyle = \u0026#39;rgba(200, 200, 200, 0.5)\u0026#39;; this.points.forEach(point =\u0026gt; { this.ctx.beginPath(); this.ctx.arc(point.x, point.y, 1, 0, 2 * Math.PI); this.ctx.fill(); }); } updatePoints() { this.points.forEach(point =\u0026gt; { point.x += point.vx; point.y += point.vy; // 边界检测 if (point.x \u0026lt; 0 || point.x \u0026gt; this.canvas.width) point.vx *= -1; if (point.y \u0026lt; 0 || point.y \u0026gt; this.canvas.height) point.vy *= -1; // 鼠标排斥 const dx = point.x - this.mouse.x; const dy = point.y - this.mouse.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance \u0026lt; 100) { const angle = Math.atan2(dy, dx); const force = (100 - distance) / 100 * 2; point.vx += Math.cos(angle) * force * 0.1; point.vy += Math.sin(angle) * force * 0.1; } // 速度限制 const speed = Math.sqrt(point.vx * point.vx + point.vy * point.vy); if (speed \u0026gt; 2) { point.vx = (point.vx / speed) * 2; point.vy = (point.vy / speed) * 2; } }); } animate() { this.updatePoints(); this.drawWeb(); requestAnimationFrame(() =\u0026gt; this.animate()); } } // 初始化蛛网背景 if (document.readyState === \u0026#39;loading\u0026#39;) { document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, () =\u0026gt; { new SpiderWeb(); }); } else { new SpiderWeb(); } 在配置文件中启用这些效果：\n[params] custom_js = [\u0026#39;js/sakura.js\u0026#39;, \u0026#39;js/spiderweb.js\u0026#39;] Firebase 集成 - 阅读量与点赞 # Firebase 项目设置 # 访问 Firebase 控制台 创建新项目并启用 Firestore 数据库 获取项目配置信息 前端集成代码 # 创建 assets/js/firebase-analytics.js：\n// Firebase 配置 const firebaseConfig = { apiKey: \u0026#34;your-api-key\u0026#34;, authDomain: \u0026#34;your-project.firebaseapp.com\u0026#34;, projectId: \u0026#34;your-project-id\u0026#34;, storageBucket: \u0026#34;your-project.appspot.com\u0026#34;, messagingSenderId: \u0026#34;123456789\u0026#34;, appId: \u0026#34;your-app-id\u0026#34; }; // 初始化 Firebase if (typeof firebase === \u0026#39;undefined\u0026#39;) { // 动态加载 Firebase SDK const script = document.createElement(\u0026#39;script\u0026#39;); script.src = \u0026#39;https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js\u0026#39;; document.head.appendChild(script); script.onload = () =\u0026gt; { const script2 = document.createElement(\u0026#39;script\u0026#39;); script2.src = \u0026#39;https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js\u0026#39;; document.head.appendChild(script2); script2.onload = () =\u0026gt; { firebase.initializeApp(firebaseConfig); initFirebaseAnalytics(); }; }; } else { initFirebaseAnalytics(); } function initFirebaseAnalytics() { const db = firebase.firestore(); // 获取文章唯一标识 const articleId = getArticleId(); if (articleId) { updateViewCount(db, articleId); setupLikeButton(db, articleId); } } function getArticleId() { // 从页面URL或meta标签获取文章ID const path = window.location.pathname; const articleSlug = path.split(\u0026#39;/\u0026#39;).filter(Boolean).pop(); return articleSlug || document.querySelector(\u0026#39;meta[property=\u0026#34;og:url\u0026#34;]\u0026#39;)?.content?.split(\u0026#39;/\u0026#39;).pop(); } async function updateViewCount(db, articleId) { const docRef = db.collection(\u0026#39;articles\u0026#39;).doc(articleId); try { const doc = await docRef.get(); if (doc.exists) { // 更新阅读量 await docRef.update({ views: firebase.firestore.FieldValue.increment(1), lastViewed: new Date() }); } else { // 创建新文档 await docRef.set({ views: 1, likes: 0, title: document.title, url: window.location.href, createdAt: new Date(), lastViewed: new Date() }); } // 显示阅读量 displayViewCount(doc); } catch (error) { console.error(\u0026#39;Error updating view count:\u0026#39;, error); } } function displayViewCount(doc) { const views = doc.exists ? doc.data().views + 1 : 1; // 创建或更新阅读量显示元素 let statsElement = document.querySelector(\u0026#39;.article-stats\u0026#39;); if (!statsElement) { statsElement = document.createElement(\u0026#39;div\u0026#39;); statsElement.className = \u0026#39;article-stats\u0026#39;; statsElement.style.margin = \u0026#39;20px 0\u0026#39;; statsElement.style.padding = \u0026#39;10px\u0026#39;; statsElement.style.background = \u0026#39;var(--surface)\u0026#39;; statsElement.style.borderRadius = \u0026#39;8px\u0026#39;; const articleHeader = document.querySelector(\u0026#39;article header\u0026#39;); if (articleHeader) { articleHeader.appendChild(statsElement); } } statsElement.innerHTML = ` \u0026lt;div style=\u0026#34;display: flex; gap: 20px; font-size: 0.9em; color: var(--on-surface);\u0026#34;\u0026gt; \u0026lt;span\u0026gt;👁️ ${views} 阅读\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;like-section\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;like-btn\u0026#34; style=\u0026#34;background: none; border: 1px solid var(--primary); color: var(--primary); padding: 2px 8px; border-radius: 4px; cursor: pointer;\u0026#34;\u0026gt;👍 \u0026lt;span id=\u0026#34;like-count\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; 点赞\u0026lt;/button\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; `; } function setupLikeButton(db, articleId) { document.addEventListener(\u0026#39;click\u0026#39;, async (e) =\u0026gt; { if (e.target.id === \u0026#39;like-btn\u0026#39; || e.target.closest(\u0026#39;#like-btn\u0026#39;)) { await handleLike(db, articleId); } }); // 初始化点赞数显示 updateLikeDisplay(db, articleId); } async function handleLike(db, articleId) { const liked = getLikeStatus(articleId); if (liked) { alert(\u0026#39;您已经点过赞了！\u0026#39;); return; } try { const docRef = db.collection(\u0026#39;articles\u0026#39;).doc(articleId); await docRef.update({ likes: firebase.firestore.FieldValue.increment(1) }); setLikeStatus(articleId); updateLikeDisplay(db, articleId); } catch (error) { console.error(\u0026#39;Error updating likes:\u0026#39;, error); } } function getLikeStatus(articleId) { return localStorage.getItem(`liked_${articleId}`) === \u0026#39;true\u0026#39;; } function setLikeStatus(articleId) { localStorage.setItem(`liked_${articleId}`, \u0026#39;true\u0026#39;); } async function updateLikeDisplay(db, articleId) { try { const doc = await db.collection(\u0026#39;articles\u0026#39;).doc(articleId).get(); if (doc.exists) { const likes = doc.data().likes || 0; const likeCountElement = document.getElementById(\u0026#39;like-count\u0026#39;); if (likeCountElement) { likeCountElement.textContent = likes; } // 更新按钮状态 const likeBtn = document.getElementById(\u0026#39;like-btn\u0026#39;); if (likeBtn \u0026amp;\u0026amp; getLikeStatus(articleId)) { likeBtn.style.background = \u0026#39;var(--primary)\u0026#39;; likeBtn.style.color = \u0026#39;white\u0026#39;; likeBtn.disabled = true; } } } catch (error) { console.error(\u0026#39;Error updating like display:\u0026#39;, error); } } 在配置中启用：\n[params] custom_js = [\u0026#39;js/firebase-analytics.js\u0026#39;, \u0026#39;js/sakura.js\u0026#39;, \u0026#39;js/spiderweb.js\u0026#39;] Live2D 看板娘集成 # 创建 assets/js/live2d.js：\n// Live2D 看板娘配置 class Live2DWidget { constructor() { this.widget = null; this.isLoaded = false; this.init(); } init() { // 延迟加载，避免影响页面性能 setTimeout(() =\u0026gt; { this.loadLive2D(); }, 3000); } loadLive2D() { const script = document.createElement(\u0026#39;script\u0026#39;); script.src = \u0026#39;https://cdn.jsdelivr.net/npm/live2d-widget@3.1.4/lib/L2Dwidget.min.js\u0026#39;; script.onload = () =\u0026gt; { L2Dwidget.init({ model: { jsonPath: \u0026#39;https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json\u0026#39;, scale: 0.8 }, display: { position: \u0026#39;right\u0026#39;, width: 200, height: 300, hOffset: 50, vOffset: -20 }, mobile: { show: true, scale: 0.5 }, react: { opacityDefault: 0.8, opacityOnHover: 1 } }); this.isLoaded = true; }; document.head.appendChild(script); } } // 初始化看板娘 if (document.readyState === \u0026#39;loading\u0026#39;) { document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, () =\u0026gt; { new Live2DWidget(); }); } else { new Live2DWidget(); } Waline 评论系统配置 # Vercel 部署 # Fork Waline 官方仓库 在 Vercel 中导入项目 配置环境变量 前端集成 # 创建 layouts/partials/comments.html：\n\u0026lt;div id=\u0026#34;waline\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 等待页面加载完成 if (document.readyState === \u0026#39;loading\u0026#39;) { document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, initWaline); } else { initWaline(); } function initWaline() { // 动态加载 Waline const script = document.createElement(\u0026#39;script\u0026#39;); script.src = \u0026#39;https://unpkg.com/@waline/client@v2/dist/waline.js\u0026#39;; script.onload = () =\u0026gt; { Waline.init({ el: \u0026#39;#waline\u0026#39;, serverURL: \u0026#39;https://your-waline-app.vercel.app\u0026#39;, path: window.location.pathname, lang: \u0026#39;zh-CN\u0026#39;, dark: \u0026#39;auto\u0026#39;, login: \u0026#39;enable\u0026#39;, reaction: true, search: false, pageview: false, // 使用 Firebase 统计 emoji: [ \u0026#39;https://unpkg.com/@waline/emojis@1.1.0/weibo\u0026#39;, \u0026#39;https://unpkg.com/@waline/emojis@1.1.0/alus\u0026#39;, \u0026#39;https://unpkg.com/@waline/emojis@1.1.0/bilibili\u0026#39;, ], commentSorting: \u0026#39;latest\u0026#39; }); }; document.head.appendChild(script); // 加载 CSS const link = document.createElement(\u0026#39;link\u0026#39;); link.rel = \u0026#39;stylesheet\u0026#39;; link.href = \u0026#39;https://unpkg.com/@waline/client@v2/dist/waline.css\u0026#39;; document.head.appendChild(link); } \u0026lt;/script\u0026gt; 在文章模板中引入评论组件：\n{{ if ne .Params.comments false }} \u0026lt;section class=\u0026#34;article-comments\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;评论\u0026lt;/h2\u0026gt; {{ partial \u0026#34;comments.html\u0026#34; . }} \u0026lt;/section\u0026gt; {{ end }} 性能优化配置 # 资源加载优化 # 在 hugo.toml 中配置：\n[services] [services.googleAnalytics] id = \u0026#39;G-XXXXXXXXXX\u0026#39; # Google Analytics 4 [params] # 延迟加载图片 image_lazy_loading = true # 压缩 HTML minify = true # 缓存配置 [caches] [caches.images] maxAge = 31536000 自定义 CSS 优化 # 在 assets/css/custom.css 中添加性能优化样式：\n/* 减少动画对性能的影响 */ canvas { will-change: transform; transform: translateZ(0); } /* 图片懒加载样式 */ img[data-src] { opacity: 0; transition: opacity 0.3s; } img[data-src].loaded { opacity: 1; } /* 移动端优化 */ @media (max-width: 768px) { .live2d-widget { display: none !important; } canvas { display: none; /* 移动端隐藏动态背景 */ } } /* 减少动画的偏好 */ @media (prefers-reduced-motion: reduce) { * { animation-duration: 0.01ms !important; animation-iteration-count: 1 !important; transition-duration: 0.01ms !important; } canvas { display: none !important; } } 部署配置 # GitHub Actions 工作流 # 创建 .github/workflows/deploy.yml：\nname: Deploy Hugo Site on: push: branches: [ main ] pull_request: branches: [ main ] jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: submodules: recursive - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.GH_PAT }} external_repository: username/username.github.io publish_branch: main publish_dir: ./public force_orphan: true 所有配置都遵循模块化原则，可以根据需要选择性启用。\n","date":"2025 年 10 月 8 日","externalUrl":null,"permalink":"/posts/blowfish%E4%B8%BB%E9%A2%98%E6%B7%B1%E5%BA%A6%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%BE%8E%E5%8C%96/","section":"Posts","summary":"","title":"Blowfish主题深度配置与美化","type":"posts"},{"content":"","date":"2025 年 10 月 8 日","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025 年 10 月 8 日","externalUrl":null,"permalink":"/","section":"葉のBlog","summary":"","title":"葉のBlog","type":"page"},{"content":"本文将详细介绍如何配置 GitHub Actions 工作流，实现推送代码到仓库后自动生成静态文件并部署到 GitHub Pages 的完整流程。\n理解自动化部署流程 # 在传统的手动部署方式中，我们需要在本地构建静态文件，然后将构建产物推送到服务器。而使用 GitHub Actions 后，整个流程可以实现完全自动化：\n推送代码到源代码仓库 GitHub Actions 自动触发工作流 在 GitHub 服务器上安装依赖和构建工具 执行构建命令生成静态文件 将构建产物推送到部署仓库或分支 GitHub Pages 自动更新网站内容 这种自动化部署方式不仅提高了效率，还确保了构建环境的一致性。\n创建仓库结构 # 源代码仓库 # 首先创建一个用于存放网站源代码的仓库，命名为任意名称，如 my-blog-source。这个仓库将包含：\n网站的源代码和配置文件 GitHub Actions 工作流文件 其他开发相关文件 部署仓库 # 对于 GitHub Pages，有两种常见的部署方式：\n方式一：同一仓库的不同分支\n源代码存放在 main 分支 构建产物推送到 gh-pages 分支 方式二：不同的仓库\n源代码存放在源代码仓库 构建产物推送到专门的部署仓库（如 username.github.io） 本文将以方式二为例进行说明，但两种方式的核心配置思路相似。\n配置 GitHub Actions 工作流 # 创建工作流文件 # 在源代码仓库的根目录下创建 .github/workflows/deploy.yml 文件。这个文件定义了自动化部署的整个流程。\n基础工作流配置 # name: Deploy to GitHub Pages on: push: branches: [ main ] pull_request: branches: [ main ] jobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout source code uses: actions/checkout@v4 with: submodules: recursive - name: Setup Node.js uses: actions/setup-node@v4 with: node-version: \u0026#39;18\u0026#39; cache: \u0026#39;npm\u0026#39; - name: Install dependencies run: npm install - name: Build static files run: npm run build - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.GH_PAT }} external_repository: username/username.github.io publish_branch: main publish_dir: ./dist force_orphan: true 工作流详解 # 触发器配置\non: push: branches: [ main ] pull_request: branches: [ main ] 这里配置了在向 main 分支推送代码或创建拉取请求时触发工作流。\n环境设置\nruns-on: ubuntu-latest 指定工作流在最新的 Ubuntu 环境中运行，确保环境一致性。\n代码检出\n- name: Checkout source code uses: actions/checkout@v4 with: submodules: recursive actions/checkout 动作用于检出仓库代码，submodules: recursive 参数确保同时检出 Git 子模块。\n构建环境配置\n- name: Setup Node.js uses: actions/setup-node@v4 with: node-version: \u0026#39;18\u0026#39; cache: \u0026#39;npm\u0026#39; 这里以 Node.js 项目为例，设置 Node.js 环境并启用 npm 缓存以加速后续构建。\n针对不同静态网站生成器的配置 # Hugo 网站配置 # 对于 Hugo 网站，工作流配置如下：\nname: Deploy Hugo Site on: push: branches: [ main ] jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout source code uses: actions/checkout@v4 with: submodules: recursive - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build static files run: hugo --minify - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.GH_PAT }} external_repository: username/username.github.io publish_branch: main publish_dir: ./public 关键点说明：\n使用 peaceiris/actions-hugo 动作安装 Hugo extended: true 确保安装扩展版 Hugo，支持 SCSS 构建目录默认为 ./public VuePress 网站配置 # 对于 VuePress 网站，工作流配置：\nname: Deploy VuePress Site on: push: branches: [ main ] jobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout source code uses: actions/checkout@v4 - name: Setup Node.js uses: actions/setup-node@v4 with: node-version: \u0026#39;18\u0026#39; cache: \u0026#39;npm\u0026#39; - name: Install dependencies run: npm install - name: Build static files run: npm run docs:build - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.GH_PAT }} external_repository: username/username.github.io publish_branch: main publish_dir: ./docs/.vuepress/dist Hexo 网站配置 # 对于 Hexo 网站，工作流配置：\nname: Deploy Hexo Site on: push: branches: [ main ] jobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout source code uses: actions/checkout@v4 - name: Setup Node.js uses: actions/setup-node@v4 with: node-version: \u0026#39;18\u0026#39; cache: \u0026#39;npm\u0026#39; - name: Install dependencies run: | npm install npm install hexo-cli -g - name: Generate static files run: hexo generate - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.GH_PAT }} external_repository: username/username.github.io publish_branch: main publish_dir: ./public 配置访问令牌 # 为了实现自动推送构建产物到部署仓库，需要配置访问令牌。\n创建个人访问令牌 # 登录 GitHub，进入 Settings → Developer settings → Personal access tokens 点击 \u0026ldquo;Generate new token\u0026rdquo; 设置令牌描述，选择过期时间 勾选 repo 权限范围 生成令牌并妥善保存 在仓库中配置密钥 # 进入源代码仓库的 Settings → Secrets and variables → Actions 点击 \u0026ldquo;New repository secret\u0026rdquo; 名称设置为 GH_PAT，值填入刚才创建的个人访问令牌 保存密钥 高级配置技巧 # 使用 GitHub Token # 如果不使用个人访问令牌，也可以使用 GitHub 自动提供的 GITHUB_TOKEN：\n- name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 注意：GITHUB_TOKEN 只能推送到同一仓库的不同分支，不能推送到外部仓库。\n条件部署 # 可以配置只在特定条件下执行部署，例如：\n- name: Deploy to GitHub Pages if: github.event_name == \u0026#39;push\u0026#39; \u0026amp;\u0026amp; github.ref == \u0026#39;refs/heads/main\u0026#39; uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.GH_PAT }} external_repository: username/username.github.io publish_branch: main publish_dir: ./public 多环境部署 # 可以配置不同的环境部署到不同的位置：\n- name: Deploy to Staging if: github.ref == \u0026#39;refs/heads/develop\u0026#39; uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.GH_PAT }} external_repository: username/staging.github.io publish_branch: main publish_dir: ./public - name: Deploy to Production if: github.ref == \u0026#39;refs/heads/main\u0026#39; uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.GH_PAT }} external_repository: username/username.github.io publish_branch: main publish_dir: ./public 缓存优化 # 对于依赖较多的项目，可以添加缓存步骤加速构建：\n- name: Cache dependencies uses: actions/cache@v3 with: path: | **/node_modules ~/.npm key: ${{ runner.os }}-node-${{ hashFiles(\u0026#39;**/package-lock.json\u0026#39;) }} restore-keys: | ${{ runner.os }}-node- 故障排除 # 常见问题及解决方法 # 构建失败\n检查工作流日志中的错误信息 确认本地构建可以成功 验证依赖版本兼容性 部署失败\n确认访问令牌有足够的权限 检查目标仓库和分支是否存在 验证部署目录路径是否正确 缓存问题\n清除缓存后重新运行工作流 检查缓存键的配置是否合理 调试技巧 # 在工作流中添加调试步骤： - name: Debug information run: | echo \u0026#34;Current directory: $(pwd)\u0026#34; ls -la echo \u0026#34;Node version: $(node --version)\u0026#34; echo \u0026#34;NPM version: $(npm --version)\u0026#34; 启用步骤调试： - name: Debug step run: | echo \u0026#34;::debug::This is a debug message\u0026#34; echo \u0026#34;::warning::This is a warning\u0026#34; echo \u0026#34;::error::This is an error\u0026#34; 检查工作流运行日志： 进入仓库的 Actions 页面 点击具体的工作流运行 查看每个步骤的详细日志 ","date":"2025 年 10 月 8 日","externalUrl":null,"permalink":"/posts/%E4%BD%BF%E7%94%A8github-actions%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/","section":"Posts","summary":"","title":"使用Github Actions实现自动构建部署静态网站","type":"posts"},{"content":"本文将详细介绍如何使用 Hugo 静态网站生成器配合 Blowfish 主题创建个人博客，并将其部署到 GitHub Pages 实现免费访问。\n环境准备 # 在开始之前，需要在本地计算机上完成必要的环境配置。\n安装 Git # Git 是版本控制工具，也是后续部署的必要条件。\n访问 Git 官网 (git-scm.com) 下载并安装对应操作系统的版本。安装完成后，在终端中执行以下命令验证安装是否成功：\ngit --version 安装 Hugo # Hugo 是一个用 Go 语言编写的静态网站生成器，以其生成速度快著称。\n访问 Hugo GitHub 发布页面 (github.com/gohugoio/hugo/releases) 下载适合您操作系统的版本。或者，如果您使用 macOS 和 Homebrew，可以通过以下命令安装：\nbrew install hugo 安装完成后，验证 Hugo 是否安装成功：\nhugo version 确保安装的是 Hugo Extended 版本，这对 Blowfish 主题的 Sass/SCSS 处理是必需的。\n创建 Hugo 网站 # 完成环境准备后，可以开始创建 Hugo 网站。\n初始化新网站 # 在终端中，导航到您希望创建网站的目录，然后执行：\nhugo new site myblog cd myblog 这将创建一个名为 \u0026ldquo;myblog\u0026rdquo; 的新目录，其中包含 Hugo 网站的基本结构。\n初始化 Git 仓库 # 进入网站目录后，将其初始化为 Git 仓库：\ngit init 安装 Blowfish 主题 # Blowfish 是一个设计优雅、功能丰富的 Hugo 主题。\n添加主题为子模块 # 推荐将主题添加为 Git 子模块，这样可以方便地更新：\ngit submodule add https://github.com/nunocoracao/blowfish.git themes/blowfish 基础配置 # 在网站根目录下创建 hugo.toml 配置文件（Hugo v0.110.0 及以上版本使用此名称，旧版本使用 config.toml），并添加以下基本配置：\ntitle = \u0026#34;我的个人博客\u0026#34; theme = \u0026#34;blowfish\u0026#34; [params] description = \u0026#34;这是我的个人博客网站\u0026#34; 配置 Blowfish 主题 # Blowfish 主题提供了丰富的自定义选项。\n基本参数配置 # 在 hugo.toml 中添加更多主题配置：\n[params] description = \u0026#34;分享技术思考和生活感悟\u0026#34; copyright = \u0026#34;© 2023 我的博客. 保留所有权利.\u0026#34; author = \u0026#34;您的名字\u0026#34; # 主题特色配置 [params.article] readingTime = true # 显示阅读时间 toc = true # 显示目录 # 主页配置 [params.home] layout = \u0026#34;profile\u0026#34; # 主页布局类型 菜单配置 # 创建网站菜单。首先在 config/_default 目录下创建 menus.toml 文件：\n[[main]] name = \u0026#34;首页\u0026#34; pageRef = \u0026#34;/\u0026#34; weight = 1 [[main]] name = \u0026#34;文章\u0026#34; pageRef = \u0026#34;/posts\u0026#34; weight = 2 [[main]] name = \u0026#34;关于\u0026#34; pageRef = \u0026#34;/about\u0026#34; weight = 3 然后创建对应的内容目录：\nhugo new about.md 编辑 content/about.md，将 draft: true 改为 draft: false。\n创建内容 # 现在可以开始为博客添加内容了。\n创建第一篇文章 # 使用 Hugo 命令创建新文章：\nhugo new posts/我的第一篇文章.md 这将在 content/posts 目录下创建一个新的 Markdown 文件。打开该文件，您会看到类似以下的内容：\n--- title: \u0026#34;我的第一篇文章\u0026#34; date: 2023-04-01T15:30:00+08:00 draft: true --- 这里是文章内容... 将 draft: true 改为 draft: false，然后在 --- 下方添加您的文章内容。\n文章前置参数 # Blowfish 主题支持多种文章前置参数，可以增强文章显示效果：\n--- title: \u0026#34;我的第一篇文章\u0026#34; date: 2023-04-01T15:30:00+08:00 draft: false description: \u0026#34;这篇文章介绍了如何搭建 Hugo 博客\u0026#34; tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Blowfish\u0026#34;, \u0026#34;GitHub Pages\u0026#34;] categories: [\u0026#34;技术\u0026#34;] cover: image: \u0026#34;images/cover.jpg\u0026#34; # 封面图片 alt: \u0026#34;文章封面\u0026#34; --- 本地测试 # 在部署之前，先在本地测试网站效果。\n启动开发服务器 # 在网站根目录下执行：\nhugo server -D -D 参数表示包含草稿文章。执行后，终端会显示服务器地址，通常是 http://localhost:1313。\n在浏览器中打开该地址，即可查看网站效果。开发服务器支持热重载，当您修改内容时，浏览器会自动刷新。\n构建静态文件 # 当您准备发布网站时，使用以下命令生成静态文件：\nhugo 这会在 public 目录下生成所有静态文件，这些文件可以直接部署到任何 Web 服务器。\n部署到 GitHub Pages # GitHub Pages 提供免费的静态网站托管服务，非常适合 Hugo 网站。\n创建 GitHub 仓库 # 在 GitHub 上创建一个新仓库，命名为 您的用户名.github.io。例如，如果您的 GitHub 用户名是 \u0026ldquo;john\u0026rdquo;，则仓库名应为 \u0026ldquo;john.github.io\u0026rdquo;。\n创建部署脚本 # 在网站根目录下创建 .github/workflows/gh-pages.yml 文件：\nname: Deploy to GitHub Pages on: push: branches: [ main ] jobs: build-deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v3 with: submodules: true - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.GITHUB_TOKEN }} external_repository: 您的用户名/您的用户名.github.io publish_branch: main publish_dir: ./public force_orphan: true 注意将 您的用户名 替换为实际的 GitHub 用户名。\n配置仓库 # 在源代码仓库的 Settings -\u0026gt; Pages 中，将 Source 设置为 \u0026ldquo;GitHub Actions\u0026rdquo;。\n推送代码 # 将本地代码推送到 GitHub 仓库：\ngit add . git commit -m \u0026#34;初始提交\u0026#34; git branch -M main git remote add origin https://github.com/您的用户名/您的源代码仓库名.git git push -u origin main GitHub Actions 会自动构建并部署您的网站。完成后，可以通过 https://您的用户名.github.io 访问您的博客。\n自定义与优化 # 修改主题颜色 # Blowfish 主题支持多种颜色方案。在 hugo.toml 中添加：\n[params] colorScheme = \u0026#34;blowfish\u0026#34; # 可选: blowfish, avocado, etc. 添加评论系统 # 要添加评论功能，可以使用 Giscus（基于 GitHub Discussions）：\n[params.giscus] repo = \u0026#34;您的用户名/您的仓库名\u0026#34; repoID = \u0026#34;您的仓库ID\u0026#34; category = \u0026#34;Announcements\u0026#34; categoryID = \u0026#34;您的分类ID\u0026#34; 配置搜索功能 # Blowfish 主题内置了搜索功能，需要额外配置：\n[services.algolia] index = \u0026#34;您的索引名\u0026#34; appID = \u0026#34;您的应用ID\u0026#34; searchKey = \u0026#34;您的搜索密钥\u0026#34; 常见问题 # 页面显示 404 错误 # 确保在 GitHub Pages 设置中正确配置了发布源，并且 GitHub Actions 工作流已成功运行。\n样式丢失 # 检查是否使用了 Hugo Extended 版本，这是处理 Blowfish 主题 SCSS 文件所必需的。\n菜单不显示 # 确认 menus.toml 文件位于 config/_default 目录下，并且页面引用正确。\n总结 # 通过本教程，您已经成功使用 Hugo 和 Blowfish 主题创建了一个个人博客，并将其部署到 GitHub Pages。您现在可以：\n在本地编写 Markdown 格式的文章 使用 Git 管理网站版本 通过 GitHub Actions 自动部署更新 通过自定义配置调整网站外观和功能 Hugo 配合 GitHub Pages 提供了一个强大且免费的博客解决方案，适合技术人员和个人博主使用。随着需求的增加，您可以进一步探索 Hugo 和 Blowfish 主题的更多高级功能，如图片处理、短代码和多语言支持等。\n","date":"2025 年 10 月 8 日","externalUrl":null,"permalink":"/posts/%E4%BD%BF%E7%94%A8github-page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","section":"Posts","summary":"","title":"使用Github Page搭建个人博客","type":"posts"},{"content":"本文记录了将 Cudy TR3000（256MB 版本）路由器刷入 OpenWrt 固件的完整流程，涵盖固件选择、刷写步骤、网络接口配置、无线网络设置和插件安装等关键环节。\n准备工作 # 确认您的 Cudy TR3000 为 256MB 版本，这是使用本教程的前提条件。准备一台 Windows 电脑和一根网线。\n需要下载的固件文件包括：\n过渡固件：cudy_tr3000-256mb-v1-sysupgrade.bin 正式固件：建议从 OpenWrt 官网下载稳定版本 UBOOT 文件（可选）：用于增强刷机灵活性 注意事项：刷机可能导致路由器失去保修，存在变砖风险。请确保下载的文件完整无误，并在操作过程中保持供电稳定。\n固件刷写过程 # 第一阶段：刷入过渡固件 # 使用网线连接电脑和路由器的 LAN 口，登录原厂管理界面。进入系统升级页面，选择过渡固件文件进行上传。系统将自动完成验证和写入，整个过程约 5-10 分钟。刷写成功后，路由器管理地址通常会变为 192.168.1.1。\n第二阶段：刷入正式固件 # 在过渡系统界面中，进入系统升级功能，选择下载的正式 OpenWrt 固件。系统会再次进行刷写和重启。完成后建议执行一次出厂重置，确保系统配置的纯净。\n可选步骤：UBOOT 刷写 # 如需更灵活的固件管理，可刷写第三方 UBOOT。这一步需要一定的技术基础，普通用户建议跳过。刷写方法请参考相关技术文档。\n网络接口配置 # 局域网设置 # LAN 口建议设置为静态 IP 地址，如 192.168.1.1，子网掩码 255.255.255.0。同时配置 DHCP 服务，为接入设备自动分配 IP 地址。注意避免与现有网络地址段冲突。\n广域网设置 # 根据上网方式选择相应配置：\nDHCP 客户端：适用于从光猫或上级路由器自动获取 IP PPPoE 拨号：需要输入宽带账号和密码 静态 IP：使用运营商提供的固定地址 配置完成后测试网络连通性，确保可以正常访问互联网。\n无线网络配置 # OpenWrt 初始状态下的无线功能默认关闭，需要手动启用。\n进入无线设置界面，分别配置 2.4GHz 和 5GHz 频段。设置网络名称（SSID）后，务必在无线安全选项中启用 WPA2-PSK 加密，并设置可靠的密码。\n信道选择建议：\n2.4GHz 频段优先选择 1、6、11 信道 5GHz 频段选择干扰较少的高频段信道 插件安装 # OpenWrt 的插件系统提供了丰富的功能扩展。安装方式主要有三种：\n在线安装：通过系统自带的软件包管理界面直接安装 本地安装：上传下载的 IPK 文件进行安装 命令行安装：通过 SSH 连接使用 opkg 命令安装 常用插件推荐：\n广告屏蔽：如 AdBlock 网络监控：用于流量统计和分析 VPN 支持：包括 OpenVPN、WireGuard 等 安装插件时应注意系统兼容性，避免安装过多插件影响稳定性。\n故障排除 # 管理界面无法访问 # 检查电脑 IP 是否与路由器同网段，尝试使用 192.168.1.1、192.168.6.1 等常见地址。清除浏览器缓存或更换浏览器尝试。\n无线信号问题 # 尝试调整无线信道和发射功率，更新无线驱动。检查周围环境是否存在干扰源。\n系统恢复 # 如果刷机失败导致路由器无法启动，可通过 TFTP 方式尝试恢复。具体操作是设置电脑静态 IP 为 192.168.1.2，在路由器启动时进入恢复模式，使用 TFTP 工具上传恢复固件。\n总结 # 成功刷入 OpenWrt 后，Cudy TR3000 可以获得更强大的网络功能和更灵活的控制权限。建议在稳定运行基础系统后，再根据实际需求逐步安装插件。\n刷机操作需要谨慎，建议在操作前充分了解每个步骤的含义和风险。保持良好的备份习惯，定期保存重要配置。\n","date":"2025 年 10 月 8 日","externalUrl":null,"permalink":"/posts/cudy-tr3000-256g%E5%88%B7openwrt%E5%9B%BA%E4%BB%B6/","section":"Posts","summary":"","title":"Cudy TR3000 刷写 OpenWrt 及配置","type":"posts"},{"content":" 前言 # Sunshine和Moonlight是一对开源的游戏串流组合，可以让你在不同设备上流畅地玩主机游戏。Sunshine作为主机端的服务端，Moonlight作为客户端的接收端。\n系统要求 # 主机端（运行Sunshine） # Windows/Linux/macOS 支持硬件编码的显卡（NVIDIA/AMD/Intel） 稳定的网络连接（有线网络更佳） 客户端（运行Moonlight） # Windows/macOS/Linux/Android/iOS 支持硬件解码的设备 5GHz WiFi或有线网络 安装步骤 # 1. 安装Sunshine（主机端） # Windows系统 # # 方法一：使用安装包 # 从GitHub releases页面下载最新的Sunshine安装包 # https://github.com/LizardByte/Sunshine/releases # 方法二：使用winget（推荐） winget install LizardByte.Sunshine Linux系统 # # Ubuntu/Debian wget https://github.com/LizardByte/Sunshine/releases/download/v0.21.0/sunshine-ubuntu-22.04_0.21.0_amd64.deb sudo dpkg -i sunshine-*.deb # Arch Linux yay -S sunshine macOS系统 # # 使用Homebrew brew install sunshine 2. 配置Sunshine # 首次运行配置 # # 启动Sunshine服务 sudo sunshine # 访问Web配置界面 # 在浏览器中打开：https://localhost:47990 基本设置 # 在Web界面中配置：\nPIN码认证：设置一个PIN码用于客户端连接 分辨率：设置串流分辨率（建议1080p或1440p） 帧率：60fps或120fps 码率：根据网络状况调整（建议20-50 Mbps） 高级配置 # 编辑Sunshine配置文件：\n# 配置文件位置 # Windows: %APPDATA%\\sunshine\\sunshine.conf # Linux: ~/.config/sunshine/sunshine.conf # 常用配置项 [min] port = 47989 webserver_port = 47990 external_ip = 你的公网IP [amd] encoder = amd [nvidia] encoder = nvidia [intel] encoder = qsv 3. 安装Moonlight（客户端） # Windows客户端 # # 从Microsoft Store安装 # 或从GitHub下载：https://github.com/moonlight-stream/moonlight-qt/releases Android客户端 # # 从Google Play商店搜索\u0026#34;Moonlight Game Streaming\u0026#34; iOS客户端 # # 从App Store搜索\u0026#34;Moonlight Game Streaming\u0026#34; Linux客户端 # # Ubuntu/Debian sudo apt install moonlight-qt # Arch Linux sudo pacman -S moonlight-qt 4. 客户端连接配置 # 发现主机 # 打开Moonlight客户端 点击\u0026quot;+\u0026ldquo;添加主机 输入主机的IP地址或让应用自动发现 配对连接 # 在Moonlight中输入Sunshine显示的PIN码 完成配对过程 选择要串流的应用或游戏 网络配置 # 端口转发（如需远程访问） # # 需要在路由器中转发以下端口： # TCP: 47984, 47989, 48010 # UDP: 47998, 47999, 48000, 48002, 48010 防火墙设置 # # Windows防火墙 netsh advfirewall firewall add rule name=\u0026#34;Sunshine\u0026#34; dir=in action=allow protocol=TCP localport=47984,47989,48010 netsh advfirewall firewall add rule name=\u0026#34;Sunshine\u0026#34; dir=in action=allow protocol=UDP localport=47998,47999,48000,48002,48010 # Linux ufw sudo ufw allow 47984,47989,48010/tcp sudo ufw allow 47998,47999,48000,48002,48010/udp 优化设置 # 图形设置 # # Sunshine配置优化 [stream] hevc_mode = 1 av1_mode = 0 min_threads = 1 pacer_period = 10 # 编码设置 [video] encoder = nvidia # 根据显卡选择 bitrate = 30000 framerate = 60 slices = 1 音频设置 # [audio] backend = wasapi # Windows # backend = pulse # Linux channels = 2 sink = 默认设备 故障排除 # 常见问题解决 # 连接失败 # # 检查服务状态 sudo systemctl status sunshine # Linux sc query sunshine # Windows # 检查端口监听 netstat -an | findstr 47989 # Windows ss -tulpn | grep 47989 # Linux 性能问题 # # 降低码率设置 # 关闭HEVC编码 # 检查网络延迟 ping 目标IP地址 音频问题 # # 检查音频设备 # 重新选择音频后端 # 更新音频驱动程序 高级功能 # 自定义应用 # 在Sunshine Web界面中添加自定义应用：\n{ \u0026#34;name\u0026#34;: \u0026#34;自定义游戏\u0026#34;, \u0026#34;cmd\u0026#34;: \u0026#34;C:\\\\Games\\\\MyGame.exe\u0026#34;, \u0026#34;prep-cmd\u0026#34;: [ { \u0026#34;do\u0026#34;: \u0026#34;start\u0026#34;, \u0026#34;cmd\u0026#34;: \u0026#34;C:\\\\Utilities\\\\GameOptimizer.exe\u0026#34; } ] } 脚本自动化 # # 启动脚本示例 #!/bin/bash # 启动Sunshine并优化系统设置 echo performance | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor sudo sunshine \u0026amp; 总结 # Sunshine + Moonlight组合提供了高质量、低延迟的游戏串流体验。通过正确的配置和网络优化，你可以在任何支持Moonlight的设备上享受主机游戏的乐趣。\n","date":"2025 年 10 月 7 日","externalUrl":null,"permalink":"/posts/%E7%94%A8sunshine%E5%92%8Cmoonlight%E5%AE%9E%E7%8E%B0%E4%B8%B2%E6%B5%81/","section":"Posts","summary":"","title":"使用Sunshine和Moonlight实现串流","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]